<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>EnclaveImpl.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">enclave-api</a> &gt; <a href="index.source.html" class="el_package">com.quorum.tessera.enclave</a> &gt; <span class="el_source">EnclaveImpl.java</span></div><h1>EnclaveImpl.java</h1><pre class="source lang-java linenums">package com.quorum.tessera.enclave;

import com.quorum.tessera.encryption.*;
import com.quorum.tessera.nacl.NaclFacade;
import com.quorum.tessera.nacl.Nonce;

import java.util.List;
import java.util.Objects;
import java.util.Set;
import java.util.stream.Collectors;

import static java.util.Collections.singletonList;

public class EnclaveImpl implements Enclave {

    private final NaclFacade nacl;

    private final KeyManager keyManager;

<span class="fc" id="L20">    public EnclaveImpl(NaclFacade nacl, KeyManager keyManager) {</span>
<span class="fc" id="L21">        this.nacl = Objects.requireNonNull(nacl);</span>
<span class="fc" id="L22">        this.keyManager = Objects.requireNonNull(keyManager);</span>
<span class="fc" id="L23">    }</span>

    @Override
    public EncodedPayload encryptPayload(final byte[] message,
                                         final PublicKey senderPublicKey,
                                         final List&lt;PublicKey&gt; recipientPublicKeys) {
<span class="fc" id="L29">        final MasterKey masterKey = nacl.createMasterKey();</span>
<span class="fc" id="L30">        final Nonce nonce = nacl.randomNonce();</span>
<span class="fc" id="L31">        final Nonce recipientNonce = nacl.randomNonce();</span>

<span class="fc" id="L33">        final byte[] cipherText = nacl.sealAfterPrecomputation(message, nonce, masterKey);</span>

<span class="fc" id="L35">        final List&lt;byte[]&gt; encryptedMasterKeys = buildRecipientMasterKeys(senderPublicKey, recipientPublicKeys, recipientNonce, masterKey);</span>

<span class="fc" id="L37">        return new EncodedPayload(</span>
            senderPublicKey, cipherText, nonce, encryptedMasterKeys, recipientNonce, recipientPublicKeys
        );
    }

    @Override
    public byte[] createNewRecipientBox(final EncodedPayload payload, final PublicKey publicKey) {

<span class="fc bfc" id="L45" title="All 4 branches covered.">        if (payload.getRecipientKeys().isEmpty() || payload.getRecipientBoxes().isEmpty()) {</span>
<span class="fc" id="L46">            throw new RuntimeException(&quot;No key or recipient-box to use&quot;);</span>
        }

<span class="fc" id="L49">        final MasterKey master = this.getMasterKey(</span>
<span class="fc" id="L50">            payload.getRecipientKeys().get(0), payload.getSenderKey(),</span>
<span class="fc" id="L51">            payload.getRecipientNonce(), payload.getRecipientBoxes().get(0)</span>
        );

<span class="fc" id="L54">        final List&lt;byte[]&gt; sealedMasterKeyList = this.buildRecipientMasterKeys(</span>
<span class="fc" id="L55">            payload.getSenderKey(), singletonList(publicKey), payload.getRecipientNonce(), master</span>
        );

<span class="fc" id="L58">        return sealedMasterKeyList.get(0);</span>
    }

    @Override
    public EncodedPayload encryptPayload(final RawTransaction rawTransaction,
                                         final List&lt;PublicKey&gt; recipientPublicKeys) {
<span class="fc" id="L64">        final MasterKey masterKey = this.getMasterKey(</span>
<span class="fc" id="L65">            rawTransaction.getFrom(), rawTransaction.getFrom(),</span>
<span class="fc" id="L66">            rawTransaction.getNonce(), rawTransaction.getEncryptedKey()</span>
        );

<span class="fc" id="L69">        final Nonce recipientNonce = nacl.randomNonce();</span>
<span class="fc" id="L70">        final List&lt;byte[]&gt; encryptedMasterKeys</span>
<span class="fc" id="L71">            = buildRecipientMasterKeys(rawTransaction.getFrom(), recipientPublicKeys, recipientNonce, masterKey);</span>

<span class="fc" id="L73">        return new EncodedPayload(</span>
<span class="fc" id="L74">            rawTransaction.getFrom(), rawTransaction.getEncryptedPayload(),</span>
<span class="fc" id="L75">            rawTransaction.getNonce(), encryptedMasterKeys, recipientNonce, recipientPublicKeys</span>
        );
    }

    private List&lt;byte[]&gt; buildRecipientMasterKeys(final PublicKey senderPublicKey,
                                                  final List&lt;PublicKey&gt; recipientPublicKeys,
                                                  final Nonce recipientNonce,
                                                  final MasterKey masterKey){
<span class="fc" id="L83">        final PrivateKey privateKey = keyManager.getPrivateKeyForPublicKey(senderPublicKey);</span>

<span class="fc" id="L85">        return recipientPublicKeys</span>
<span class="fc" id="L86">            .stream()</span>
<span class="fc" id="L87">            .map(publicKey -&gt; nacl.computeSharedKey(publicKey, privateKey))</span>
<span class="fc" id="L88">            .map(sharedKey -&gt; nacl.sealAfterPrecomputation(masterKey.getKeyBytes(), recipientNonce, sharedKey))</span>
<span class="fc" id="L89">            .collect(Collectors.toList());</span>
    }

    @Override
    public RawTransaction encryptRawPayload(byte[] message, PublicKey sender) {
<span class="fc" id="L94">        final MasterKey masterKey = nacl.createMasterKey();</span>
<span class="fc" id="L95">        final Nonce nonce = nacl.randomNonce();</span>

<span class="fc" id="L97">        final byte[] cipherText = nacl.sealAfterPrecomputation(message, nonce, masterKey);</span>

<span class="fc" id="L99">        final PrivateKey privateKey = keyManager.getPrivateKeyForPublicKey(sender);</span>

        // TODO NL - check if it makes sense to compute a shared key from the public and private parts of the same key
<span class="fc" id="L102">        SharedKey sharedKey = nacl.computeSharedKey(sender, privateKey);</span>
<span class="fc" id="L103">        final byte[] encryptedMasterKey = nacl.sealAfterPrecomputation(masterKey.getKeyBytes(), nonce, sharedKey);</span>

<span class="fc" id="L105">        return new RawTransaction(cipherText, encryptedMasterKey, nonce, sender);</span>
    }

    @Override
    public byte[] unencryptTransaction(EncodedPayload payload, final PublicKey providedSenderKey) {

        final PublicKey senderPubKey;

        final PublicKey recipientPubKey;

<span class="fc bfc" id="L115" title="All 2 branches covered.">        if (!this.getPublicKeys().contains(payload.getSenderKey())) {</span>
            // This is a payload originally sent to us by another node
<span class="fc" id="L117">            senderPubKey = providedSenderKey;</span>
<span class="fc" id="L118">            recipientPubKey = payload.getSenderKey();</span>
        } else {
            // This is a payload that originated from us
<span class="fc" id="L121">            senderPubKey = payload.getSenderKey();</span>
<span class="fc" id="L122">            recipientPubKey = payload.getRecipientKeys().get(0);</span>
        }

<span class="fc" id="L125">        final PrivateKey senderPrivKey = keyManager.getPrivateKeyForPublicKey(senderPubKey);</span>

<span class="fc" id="L127">        final SharedKey sharedKey = nacl.computeSharedKey(recipientPubKey, senderPrivKey);</span>

<span class="fc" id="L129">        final byte[] recipientBox = payload.getRecipientBoxes().iterator().next();</span>

<span class="fc" id="L131">        final Nonce recipientNonce = payload.getRecipientNonce();</span>

<span class="fc" id="L133">        final byte[] masterKeyBytes = nacl.openAfterPrecomputation(recipientBox, recipientNonce, sharedKey);</span>

<span class="fc" id="L135">        final MasterKey masterKey = MasterKey.from(masterKeyBytes);</span>

<span class="fc" id="L137">        final byte[] cipherText = payload.getCipherText();</span>
<span class="fc" id="L138">        final Nonce cipherTextNonce = payload.getCipherTextNonce();</span>

<span class="fc" id="L140">        return nacl.openAfterPrecomputation(cipherText, cipherTextNonce, masterKey);</span>

    }

    private MasterKey getMasterKey(PublicKey recipient, PublicKey sender, Nonce nonce, byte[] encryptedKey) {

<span class="fc" id="L146">        final SharedKey sharedKey = nacl.computeSharedKey(recipient, keyManager.getPrivateKeyForPublicKey(sender));</span>

<span class="fc" id="L148">        final byte[] masterKeyBytes = nacl.openAfterPrecomputation(encryptedKey, nonce, sharedKey);</span>

<span class="fc" id="L150">        return MasterKey.from(masterKeyBytes);</span>
    }

    @Override
    public PublicKey defaultPublicKey() {
<span class="fc" id="L155">        return keyManager.defaultPublicKey();</span>
    }

    @Override
    public Set&lt;PublicKey&gt; getForwardingKeys() {
<span class="fc" id="L160">        return keyManager.getForwardingKeys();</span>
    }

    @Override
    public Set&lt;PublicKey&gt; getPublicKeys() {
<span class="fc" id="L165">        return keyManager.getPublicKeys();</span>
    }

    @Override
    public Status status() {
<span class="fc" id="L170">        return Status.STARTED;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>