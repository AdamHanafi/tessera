<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>CliDelegate.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">cli-api</a> &gt; <a href="index.source.html" class="el_package">com.quorum.tessera.cli</a> &gt; <span class="el_source">CliDelegate.java</span></div><h1>CliDelegate.java</h1><pre class="source lang-java linenums">package com.quorum.tessera.cli;

import com.quorum.tessera.ServiceLoaderUtil;
import com.quorum.tessera.cli.parsers.ConfigConverter;
import com.quorum.tessera.config.Config;
import picocli.CommandLine;

import java.util.ArrayList;
import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;

import static picocli.CommandLine.Model.CommandSpec.DEFAULT_COMMAND_NAME;

<span class="fc" id="L15">public enum CliDelegate {</span>
<span class="fc" id="L16">    INSTANCE;</span>

    private Config config;

    public static CliDelegate instance() {
<span class="fc" id="L21">        return INSTANCE;</span>
    }

    public Config getConfig() {
<span class="fc" id="L25">        return Optional.ofNullable(config)</span>
<span class="fc" id="L26">                .orElseThrow(</span>
<span class="fc" id="L27">                        () -&gt; new IllegalStateException(&quot;Execute must be invoked before attempting to fetch config&quot;));</span>
    }

    public CliResult execute(String... args) throws Exception {

<span class="fc" id="L32">        final List&lt;CliAdapter&gt; adapters = ServiceLoaderUtil.loadAll(CliAdapter.class).collect(Collectors.toList());</span>

        // Finds the top level adapter that we want to start with. Exactly one is expected to be on the classpath.
<span class="fc" id="L35">        final CliAdapter adapter =</span>
<span class="fc" id="L36">                adapters.stream()</span>
<span class="fc" id="L37">                        .filter(a -&gt; a.getClass().isAnnotationPresent(CommandLine.Command.class))</span>
<span class="fc" id="L38">                        .filter(</span>
                                a -&gt;
<span class="fc" id="L40">                                        a.getClass()</span>
<span class="fc" id="L41">                                                .getAnnotation(CommandLine.Command.class)</span>
<span class="fc" id="L42">                                                .name()</span>
<span class="fc" id="L43">                                                .equals(DEFAULT_COMMAND_NAME))</span>
<span class="fc" id="L44">                        .findFirst()</span>
<span class="fc" id="L45">                        .get();</span>

        // The will find all the others and attach them as sub-commands. It is expected that they have defined their
        // own hierarchy and command names.
<span class="fc" id="L49">        final List&lt;CliAdapter&gt; others = new ArrayList&lt;&gt;(adapters);</span>
<span class="fc" id="L50">        others.remove(adapter);</span>

        // the mapper will give us access to the exception from the outside, if one occurred.
        // mostly since we have an existing system, and this is a workaround
<span class="fc" id="L54">        final CLIExceptionCapturer mapper = new CLIExceptionCapturer();</span>
<span class="fc" id="L55">        final CommandLine commandLine = new CommandLine(adapter);</span>
<span class="fc" id="L56">        others.forEach(commandLine::addSubcommand);</span>

<span class="fc" id="L58">        commandLine</span>
<span class="fc" id="L59">                .registerConverter(Config.class, new ConfigConverter())</span>
<span class="fc" id="L60">                .setSeparator(&quot; &quot;)</span>
<span class="fc" id="L61">                .setUnmatchedArgumentsAllowed(true)</span>
<span class="fc" id="L62">                .setExecutionExceptionHandler(mapper);</span>

<span class="fc" id="L64">        commandLine.execute(args);</span>

        // if an exception occurred, throw it to to the upper levels where it gets handled
<span class="fc bfc" id="L67" title="All 2 branches covered.">        if (mapper.getThrown() != null) {</span>
<span class="fc" id="L68">            throw mapper.getThrown();</span>
        }

        // otherwise, set the config object (if there is one) and return
<span class="fc" id="L72">        final CliResult result = this.getResult(commandLine.getParseResult());</span>
<span class="fc" id="L73">        this.config = Optional.ofNullable(result).flatMap(CliResult::getConfig).orElse(null);</span>
<span class="fc" id="L74">        return result;</span>
    }

    // checks all the commands thats ran for a result, and returns it, or null otherwise
    public CliResult getResult(final CommandLine.ParseResult parseResult) {
<span class="fc bfc" id="L79" title="All 2 branches covered.">        if (parseResult == null) {</span>
<span class="fc" id="L80">            return null;</span>
        }

<span class="fc" id="L83">        final CliResult result = parseResult.commandSpec().commandLine().getExecutionResult();</span>
<span class="fc bfc" id="L84" title="All 2 branches covered.">        if (result != null) {</span>
<span class="fc" id="L85">            return result;</span>
        }

<span class="fc" id="L88">        return getResult(parseResult.subcommand());</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>