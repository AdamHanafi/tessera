<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>TransactionManagerImpl.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">tessera-core</a> &gt; <a href="index.source.html" class="el_package">com.quorum.tessera.transaction</a> &gt; <span class="el_source">TransactionManagerImpl.java</span></div><h1>TransactionManagerImpl.java</h1><pre class="source lang-java linenums">package com.quorum.tessera.transaction;

import com.quorum.tessera.api.model.*;
import com.quorum.tessera.enclave.Enclave;
import com.quorum.tessera.enclave.EnclaveException;
import com.quorum.tessera.enclave.EncodedPayload;
import com.quorum.tessera.enclave.PayloadEncoder;
import com.quorum.tessera.enclave.RawTransaction;
import com.quorum.tessera.enclave.model.MessageHash;
import com.quorum.tessera.enclave.model.MessageHashFactory;
import com.quorum.tessera.encryption.PublicKey;
import com.quorum.tessera.nacl.NaclException;
import com.quorum.tessera.transaction.exception.KeyNotFoundException;
import com.quorum.tessera.transaction.exception.PublishPayloadException;
import com.quorum.tessera.transaction.exception.TransactionNotFoundException;
import com.quorum.tessera.transaction.model.EncryptedRawTransaction;
import com.quorum.tessera.transaction.model.EncryptedTransaction;
import com.quorum.tessera.util.Base64Decoder;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.transaction.Transactional;
import java.util.List;
import java.util.Objects;
import java.util.Optional;
import java.util.stream.Collectors;
import java.util.stream.Stream;

/**
 * Delegate/Mediator object to normalise calls/interactions between Enclave and
 * Base64Decoder
 *
 * @see {Base64Decoder}
 * @see {Enclave}
 */
public class TransactionManagerImpl implements TransactionManager {

<span class="fc" id="L38">    private static final Logger LOGGER = LoggerFactory.getLogger(TransactionManagerImpl.class);</span>

    private final PayloadEncoder payloadEncoder;

    private final Base64Decoder base64Decoder;

    private final EncryptedTransactionDAO encryptedTransactionDAO;

    private final EncryptedRawTransactionDAO encryptedRawTransactionDAO;

    private final PayloadPublisher payloadPublisher;

    private final Enclave enclave;

    private final ResendManager resendManager;

<span class="fc" id="L54">    private final MessageHashFactory messageHashFactory = MessageHashFactory.create();</span>

    public TransactionManagerImpl(
            Base64Decoder base64Decoder,
            PayloadEncoder payloadEncoder,
            EncryptedTransactionDAO encryptedTransactionDAO,
            PayloadPublisher payloadPublisher,
            Enclave enclave,
            EncryptedRawTransactionDAO encryptedRawTransactionDAO,
<span class="fc" id="L63">            ResendManager resendManager) {</span>

<span class="fc" id="L65">        this.base64Decoder = Objects.requireNonNull(base64Decoder);</span>
<span class="fc" id="L66">        this.payloadEncoder = Objects.requireNonNull(payloadEncoder);</span>
<span class="fc" id="L67">        this.encryptedTransactionDAO = Objects.requireNonNull(encryptedTransactionDAO);</span>
<span class="fc" id="L68">        this.payloadPublisher = Objects.requireNonNull(payloadPublisher);</span>
<span class="fc" id="L69">        this.enclave = Objects.requireNonNull(enclave);</span>
<span class="fc" id="L70">        this.encryptedRawTransactionDAO = Objects.requireNonNull(encryptedRawTransactionDAO);</span>
<span class="fc" id="L71">        this.resendManager = Objects.requireNonNull(resendManager);</span>
<span class="fc" id="L72">    }</span>

    @Override
    @Transactional
    public SendResponse send(SendRequest sendRequest) {

<span class="fc" id="L78">        final String sender = sendRequest.getFrom();</span>

<span class="fc" id="L80">        final PublicKey senderPublicKey = Optional.ofNullable(sender)</span>
<span class="fc" id="L81">                .map(base64Decoder::decode)</span>
<span class="fc" id="L82">                .map(PublicKey::from)</span>
<span class="fc" id="L83">                .orElseGet(enclave::defaultPublicKey);</span>

<span class="fc" id="L85">        final byte[][] recipients = Stream.of(sendRequest)</span>
<span class="fc" id="L86">                .filter(sr -&gt; Objects.nonNull(sr.getTo()))</span>
<span class="fc" id="L87">                .flatMap(s -&gt; Stream.of(s.getTo()))</span>
<span class="fc" id="L88">                .map(base64Decoder::decode)</span>
<span class="fc" id="L89">                .toArray(byte[][]::new);</span>

<span class="fc" id="L91">        final List&lt;PublicKey&gt; recipientList = Stream</span>
<span class="fc" id="L92">                .of(recipients)</span>
<span class="fc" id="L93">                .map(PublicKey::from)</span>
<span class="fc" id="L94">                .collect(Collectors.toList());</span>

<span class="fc" id="L96">        recipientList.add(senderPublicKey);</span>

<span class="fc" id="L98">        recipientList.addAll(enclave.getForwardingKeys());</span>

<span class="fc" id="L100">        final byte[] raw = sendRequest.getPayload();</span>

<span class="fc" id="L102">        final EncodedPayload payload = enclave.encryptPayload(raw, senderPublicKey, recipientList);</span>

<span class="fc" id="L104">        final MessageHash transactionHash = Optional.of(payload)</span>
<span class="fc" id="L105">                .map(EncodedPayload::getCipherText)</span>
<span class="fc" id="L106">                .map(messageHashFactory::createFromCipherText).get();</span>

<span class="fc" id="L108">        final EncryptedTransaction newTransaction</span>
<span class="fc" id="L109">            = new EncryptedTransaction(transactionHash, this.payloadEncoder.encode(payload));</span>

<span class="fc" id="L111">        this.encryptedTransactionDAO.save(newTransaction);</span>

<span class="fc" id="L113">        recipientList.forEach(recipient -&gt; {</span>
<span class="fc" id="L114">            final EncodedPayload outgoing = payloadEncoder.forRecipient(payload, recipient);</span>
<span class="fc" id="L115">            payloadPublisher.publishPayload(outgoing, recipient);</span>
<span class="fc" id="L116">        });</span>

<span class="fc" id="L118">        final byte[] key = transactionHash.getHashBytes();</span>

<span class="fc" id="L120">        final String encodedKey = base64Decoder.encodeToString(key);</span>

<span class="fc" id="L122">        return new SendResponse(encodedKey);</span>
    }

    @Override
    @Transactional
    public SendResponse sendSignedTransaction(SendSignedRequest sendRequest) {

<span class="fc" id="L129">        final byte[][] recipients = Stream.of(sendRequest)</span>
<span class="fc" id="L130">            .filter(sr -&gt; Objects.nonNull(sr.getTo()))</span>
<span class="fc" id="L131">            .flatMap(s -&gt; Stream.of(s.getTo()))</span>
<span class="fc" id="L132">            .map(base64Decoder::decode)</span>
<span class="fc" id="L133">            .toArray(byte[][]::new);</span>

<span class="fc" id="L135">        final List&lt;PublicKey&gt; recipientList = Stream</span>
<span class="fc" id="L136">            .of(recipients)</span>
<span class="fc" id="L137">            .map(PublicKey::from)</span>
<span class="fc" id="L138">            .collect(Collectors.toList());</span>

<span class="fc" id="L140">        recipientList.addAll(enclave.getForwardingKeys());</span>

<span class="fc" id="L142">        MessageHash messageHash = new MessageHash(sendRequest.getHash());</span>

<span class="fc" id="L144">        EncryptedRawTransaction encryptedRawTransaction = encryptedRawTransactionDAO.retrieveByHash(messageHash)</span>
<span class="fc" id="L145">            .orElseThrow(() -&gt; new TransactionNotFoundException(&quot;Raw Transaction with hash &quot; + messageHash + &quot; was not found&quot;));</span>

<span class="fc" id="L147">        final EncodedPayload payload</span>
<span class="fc" id="L148">            = enclave.encryptPayload(encryptedRawTransaction.toRawTransaction(), recipientList);</span>


<span class="fc" id="L151">        final EncryptedTransaction newTransaction</span>
<span class="fc" id="L152">            = new EncryptedTransaction(messageHash, this.payloadEncoder.encode(payload));</span>

<span class="fc" id="L154">        this.encryptedTransactionDAO.save(newTransaction);</span>

<span class="fc" id="L156">        recipientList.forEach(recipient -&gt; {</span>
<span class="fc" id="L157">            final EncodedPayload toPublish = payloadEncoder.forRecipient(payload, recipient);</span>
<span class="fc" id="L158">            payloadPublisher.publishPayload(toPublish, recipient);</span>
<span class="fc" id="L159">        });</span>

<span class="fc" id="L161">        final byte[] key = messageHash.getHashBytes();</span>

<span class="fc" id="L163">        final String encodedKey = base64Decoder.encodeToString(key);</span>

<span class="fc" id="L165">        return new SendResponse(encodedKey);</span>
    }

    @Override
    @Transactional
    public ResendResponse resend(ResendRequest request) {

<span class="fc" id="L172">        final byte[] publicKeyData = base64Decoder.decode(request.getPublicKey());</span>
<span class="fc" id="L173">        PublicKey recipientPublicKey = PublicKey.from(publicKeyData);</span>
<span class="fc bfc" id="L174" title="All 2 branches covered.">        if (request.getType() == ResendRequestType.ALL) {</span>

<span class="fc" id="L176">            encryptedTransactionDAO</span>
<span class="fc" id="L177">                .retrieveAllTransactions()</span>
<span class="fc" id="L178">                .stream()</span>
<span class="fc" id="L179">                .map(EncryptedTransaction::getEncodedPayload)</span>
<span class="fc" id="L180">                .map(payloadEncoder::decode)</span>
<span class="fc" id="L181">                .filter(payload -&gt; {</span>
<span class="fc" id="L182">                    final boolean isRecipient = payload.getRecipientKeys().contains(recipientPublicKey);</span>
<span class="fc" id="L183">                    final boolean isSender = Objects.equals(payload.getSenderKey(), recipientPublicKey);</span>
<span class="fc bfc" id="L184" title="All 4 branches covered.">                    return isRecipient || isSender;</span>
<span class="fc" id="L185">                }).forEach(payload -&gt; {</span>
<span class="fc bfc" id="L186" title="All 2 branches covered.">                    if (Objects.equals(payload.getSenderKey(), recipientPublicKey)) {</span>
<span class="fc" id="L187">                        final PublicKey decryptedKey = searchForRecipientKey(payload).orElseThrow(</span>
                            () -&gt; {
<span class="fc" id="L189">                                final MessageHash hash = MessageHashFactory.create()</span>
<span class="fc" id="L190">                                    .createFromCipherText(payload.getCipherText());</span>
<span class="fc" id="L191">                                return new KeyNotFoundException(&quot;No key found as recipient of message &quot; + hash);</span>
                            }
                        );
<span class="fc" id="L194">                        payload.getRecipientKeys().add(decryptedKey);</span>
                    }

                    try {
<span class="fc" id="L198">                        payloadPublisher.publishPayload(payload, recipientPublicKey);</span>
<span class="fc" id="L199">                    } catch (PublishPayloadException ex) {</span>
<span class="fc" id="L200">                        LOGGER.warn(&quot;Unable to publish payload to recipient {} during resend&quot;, recipientPublicKey.encodeToBase64());</span>
<span class="fc" id="L201">                    }</span>

<span class="fc" id="L203">                });</span>

<span class="fc" id="L205">            return new ResendResponse();</span>
        } else {

<span class="fc" id="L208">            final byte[] hashKey = base64Decoder.decode(request.getKey());</span>
<span class="fc" id="L209">            final MessageHash messageHash = new MessageHash(hashKey);</span>

<span class="fc" id="L211">            final EncryptedTransaction encryptedTransaction = encryptedTransactionDAO</span>
<span class="fc" id="L212">                .retrieveByHash(messageHash)</span>
<span class="fc" id="L213">                .orElseThrow(() -&gt; new TransactionNotFoundException(&quot;Message with hash &quot; + messageHash + &quot; was not found&quot;));</span>

<span class="fc" id="L215">            final EncodedPayload payload = payloadEncoder.decode(encryptedTransaction.getEncodedPayload());</span>

            final EncodedPayload returnValue;
<span class="fc bfc" id="L218" title="All 2 branches covered.">            if (Objects.equals(payload.getSenderKey(), recipientPublicKey)) {</span>
<span class="fc" id="L219">                final PublicKey decryptedKey = searchForRecipientKey(payload).orElseThrow(RuntimeException::new);</span>
<span class="fc" id="L220">                payload.getRecipientKeys().add(decryptedKey);</span>
<span class="fc" id="L221">                returnValue = payload;</span>
<span class="fc" id="L222">            } else {</span>
                //this is our tx
<span class="fc" id="L224">                returnValue = payloadEncoder.forRecipient(payload, recipientPublicKey);</span>
            }

<span class="fc" id="L227">            return new ResendResponse(payloadEncoder.encode(returnValue));</span>
        }
    }

    @Override
    public MessageHash storePayload(byte[] input) {

<span class="fc" id="L234">        final EncodedPayload payload = payloadEncoder.decode(input);</span>

<span class="fc" id="L236">        final MessageHash transactionHash = Optional.of(payload)</span>
<span class="fc" id="L237">            .map(EncodedPayload::getCipherText)</span>
<span class="fc" id="L238">            .map(messageHashFactory::createFromCipherText).get();</span>

<span class="fc bfc" id="L240" title="All 2 branches covered.">        if (enclave.getPublicKeys().contains(payload.getSenderKey())) {</span>

<span class="fc" id="L242">            this.resendManager.acceptOwnMessage(input);</span>

        } else {

            //this is a tx from someone else
<span class="fc" id="L247">            this.encryptedTransactionDAO.save(new EncryptedTransaction(transactionHash, input));</span>
<span class="fc" id="L248">            LOGGER.info(&quot;Stored payload with hash {}&quot;, transactionHash);</span>

        }

<span class="fc" id="L252">        return transactionHash;</span>
    }

    @Override
    @Transactional
    public void delete(DeleteRequest request) {
<span class="fc" id="L258">        final byte[] hashBytes = base64Decoder.decode(request.getKey());</span>
<span class="fc" id="L259">        final MessageHash messageHash = new MessageHash(hashBytes);</span>

<span class="fc" id="L261">        LOGGER.info(&quot;Received request to delete message with hash {}&quot;, messageHash);</span>
<span class="fc" id="L262">        this.encryptedTransactionDAO.delete(messageHash);</span>

<span class="fc" id="L264">    }</span>

    @Override
    @Transactional
    public ReceiveResponse receive(ReceiveRequest request) {

<span class="fc" id="L270">        final byte[] key = base64Decoder.decode(request.getKey());</span>

<span class="fc" id="L272">        final Optional&lt;byte[]&gt; to = Optional</span>
<span class="fc" id="L273">                .ofNullable(request.getTo())</span>
<span class="fc bfc" id="L274" title="All 2 branches covered.">                .filter(str -&gt; !str.isEmpty())</span>
<span class="fc" id="L275">                .map(base64Decoder::decode);</span>

<span class="fc" id="L277">        final MessageHash hash = new MessageHash(key);</span>
<span class="fc" id="L278">        LOGGER.info(&quot;Lookup transaction {}&quot;,hash);</span>
        
<span class="fc" id="L280">        final EncryptedTransaction encryptedTransaction = encryptedTransactionDAO</span>
<span class="fc" id="L281">                .retrieveByHash(hash)</span>
<span class="fc" id="L282">                .orElseThrow(() -&gt; new TransactionNotFoundException(&quot;Message with hash &quot; + hash + &quot; was not found&quot;));</span>

<span class="fc" id="L284">        final EncodedPayload payload = Optional.of(encryptedTransaction)</span>
<span class="fc" id="L285">                .map(EncryptedTransaction::getEncodedPayload)</span>
<span class="fc" id="L286">                .map(payloadEncoder::decode)</span>
<span class="fc" id="L287">                .orElseThrow(() -&gt; new IllegalStateException(&quot;Unable to decode previously encoded payload&quot;));</span>

<span class="fc" id="L289">        PublicKey recipientKey = to.map(PublicKey::from)</span>
<span class="fc" id="L290">            .orElse(searchForRecipientKey(payload)</span>
<span class="fc" id="L291">                .orElseThrow(() -&gt; new NoRecipientKeyFoundException(&quot;No suitable recipient keys found to decrypt payload for : &quot; + hash))</span>
            );

<span class="fc" id="L294">        byte[] response = enclave.unencryptTransaction(payload, recipientKey);</span>

<span class="fc" id="L296">        return new ReceiveResponse(response);</span>

    }

    private Optional&lt;PublicKey&gt; searchForRecipientKey(final EncodedPayload payload) {
<span class="fc bfc" id="L301" title="All 2 branches covered.">        for (final PublicKey potentialMatchingKey : enclave.getPublicKeys()) {</span>
            try {
<span class="fc" id="L303">                enclave.unencryptTransaction(payload, potentialMatchingKey);</span>
<span class="fc" id="L304">                return Optional.of(potentialMatchingKey);</span>
<span class="fc" id="L305">            } catch (EnclaveException | IndexOutOfBoundsException | NaclException ex) {</span>
<span class="fc" id="L306">                LOGGER.debug(&quot;Attempted payload decryption using wrong key, discarding.&quot;);</span>
            }
<span class="fc" id="L308">        }</span>
<span class="fc" id="L309">        return Optional.empty();</span>
    }

    @Override
    @Transactional
    public StoreRawResponse store(StoreRawRequest storeRequest) {

<span class="fc" id="L316">        RawTransaction rawTransaction = enclave.encryptRawPayload(storeRequest.getPayload(),</span>
<span class="fc" id="L317">            storeRequest.getFrom().map(PublicKey::from).orElseGet(enclave::defaultPublicKey));</span>
<span class="fc" id="L318">        MessageHash hash = messageHashFactory.createFromCipherText(rawTransaction.getEncryptedPayload());</span>

<span class="fc" id="L320">        EncryptedRawTransaction encryptedRawTransaction = new EncryptedRawTransaction(hash,</span>
<span class="fc" id="L321">            rawTransaction.getEncryptedPayload(),</span>
<span class="fc" id="L322">            rawTransaction.getEncryptedKey(),</span>
<span class="fc" id="L323">            rawTransaction.getNonce().getNonceBytes(),</span>
<span class="fc" id="L324">            rawTransaction.getFrom().getKeyBytes());</span>

<span class="fc" id="L326">        encryptedRawTransactionDAO.save(encryptedRawTransaction);</span>

<span class="fc" id="L328">        return new StoreRawResponse(encryptedRawTransaction.getHash().getHashBytes());</span>
    }
    

    
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>